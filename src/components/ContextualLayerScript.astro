---
type ContextualEntry = {
  name: string;
  definition?: string;
  type?: "glossary" | "entity";
  title?: string;
  role?: string;
  image?: string | null;
};

type Props = {
  entries: ContextualEntry[];
  scopeSelector: string;
  toggleSelector?: string;
};

const {
  entries = [],
  scopeSelector,
  toggleSelector = "[data-contextual-toggle]",
}: Props = Astro.props;
---

<script
  is:inline
  data-contextual-entries={JSON.stringify(entries)}
  data-contextual-scope={scopeSelector}
  data-contextual-toggle={toggleSelector}
>
  (() => {
    const script = document.currentScript;
    if (!script) return;
    const entriesRaw = script.dataset.contextualEntries ?? "[]";
    const scopeSelector = script.dataset.contextualScope ?? "";
    const toggleSelector = script.dataset.contextualToggle ?? "[data-contextual-toggle]";
    const entries = JSON.parse(entriesRaw);
    if (!Array.isArray(entries) || entries.length === 0) return;

    const highlightClasses = [
      "underline",
      "decoration-amber-400",
      "decoration-2",
      "underline-offset-2",
      "cursor-pointer",
    ];

    const skipTags = new Set(["A", "BUTTON", "CODE", "PRE", "SCRIPT", "STYLE", "TEXTAREA", "INPUT", "SELECT", "OPTION", "MARK"]);

    const settings = {
      density: "first", // "all" | "first"
      showEntities: true,
      showGlossary: true,
      float: true,
      position: "hd", // hd | hg | bd | bg
    };

    const mapByKey = new Map(
      entries.map((entry) => [
        (entry?.name ?? "").toLocaleLowerCase("fr"),
        {
          name: entry?.name ?? "",
          definition: entry?.definition ?? "",
          type: entry?.type ?? "glossary",
          title: entry?.title ?? entry?.name ?? "",
          role: entry?.role ?? "",
          image: entry?.image ?? null,
        },
      ]),
    );

    const terms = Array.from(mapByKey.values())
      .map((entry) => entry.name)
      .filter(Boolean)
      .sort((a, b) => b.length - a.length);

    if (terms.length === 0) return;

    const escapedTerms = terms.map((term) =>
      term.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\$&"),
    );
    // Autorise les apostrophes et ponctuations autour du mot (ex: l’hubris)
    const boundary = `[\\s.,;:!?()\\[\\]{}"“”'’«»-]`;
    const pattern = new RegExp(`(^|${boundary})(${escapedTerms.join("|")})(?=($|${boundary}))`, "giu");

    const scope = document.querySelector(scopeSelector);
    if (!scope) return;
    const toggle = scope.querySelector(toggleSelector);
    if (!toggle) return;
    const contentRoot = scope.querySelector("[data-contextual-body]") || scope;

    let processed = false;
    let active = false;
    let markers = [];
    let currentAnchor = null;
    let hideTimer = null;
    let collapsed = false;
    let settingsPanelOpen = false;
    let settingsButton = null;
    let settingsPanel = null;
    let densityButtons = [];
    let entitiesCheckbox = null;
    let glossaryCheckbox = null;
    let floatToggle = null;
    let positionButtons = [];
    const floatUpdaters = [];
    let controlsContainer = null;
    let floaterContainer = null;
    const mobileMedia = window.matchMedia("(max-width: 768px)");

    const STORAGE_KEY = "mk-contextual-mode";
    const SETTINGS_KEY = "mk-contextual-settings";

    const tooltip = createTooltip();

    const activeBtnClasses = [
      "border-amber-400",
      "bg-amber-50",
      "text-amber-900",
      "shadow-md",
      "dark:border-amber-400/80",
      "dark:bg-amber-900/30",
      "dark:text-amber-100",
    ];
    const inactiveBtnClasses = [
      "border-slate-200",
      "bg-white",
      "text-slate-900",
      "shadow-sm",
      "dark:border-slate-700",
      "dark:bg-slate-900",
      "dark:text-slate-100",
    ];

    function persistState(isActive) {
      try {
        localStorage.setItem(STORAGE_KEY, isActive ? "on" : "off");
      } catch (_) {
        // ignore
      }
    }

    function readInitialState() {
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored === null) return true;
        return stored === "on";
      } catch (_) {
        return true;
      }
    }

    function applyState(isActive) {
      active = isActive;
      toggle.setAttribute("aria-pressed", String(isActive));
      const indicator = toggle.querySelector("[data-contextual-indicator]");

      const primaryButtons = [toggle];
      if (settingsButton) primaryButtons.push(settingsButton);

      primaryButtons.forEach((btn) => {
        activeBtnClasses.forEach((cls) => btn.classList[isActive ? "add" : "remove"](cls));
        inactiveBtnClasses.forEach((cls) => btn.classList[isActive ? "remove" : "add"](cls));
        btn.classList.toggle("ring-2", isActive && btn === toggle);
        btn.classList.toggle("ring-amber-300", isActive && btn === toggle);
        btn.classList.toggle("dark:ring-amber-400/50", isActive && btn === toggle);
      });

      if (indicator) {
        indicator.classList.toggle("bg-amber-400", isActive);
        indicator.classList.toggle("border-amber-500/80", isActive);
        indicator.classList.toggle("bg-transparent", !isActive);
        indicator.classList.toggle("border-slate-400", !isActive);
      }

      markers.forEach((marker) => {
        const enabled = isActive && isMarkerEnabled(marker);
        highlightClasses.forEach((cls) => marker.classList[enabled ? "add" : "remove"](cls));
        marker.tabIndex = enabled ? 0 : -1;
        marker.setAttribute("aria-disabled", enabled ? "false" : "true");
        if (!enabled && currentAnchor === marker) {
          hideTooltip();
        }
        marker.setAttribute("aria-pressed", "false");
      });

      if (!isActive) hideTooltip();
    }

    function init() {
      settingsButton = scope.querySelector("[data-contextual-settings]");
      settingsPanel = scope.querySelector("[data-contextual-settings-panel]");
      densityButtons = Array.from(scope.querySelectorAll("[data-context-density]"));
      entitiesCheckbox = scope.querySelector("[data-context-entities]");
      glossaryCheckbox = scope.querySelector("[data-context-glossary]");
      floatToggle = scope.querySelector("[data-context-float]");
      positionButtons = Array.from(scope.querySelectorAll("[data-context-position]"));
      controlsContainer = scope.querySelector("[data-context-controls]");
      floaterContainer = scope.querySelector("[data-contextual-floater]");

      loadSettings();
      syncSettingsUI();
      applyPosition();

      const initialActive = readInitialState();
      if (initialActive && !processed) {
        try {
          markers = wrapContent(contentRoot);
          processed = true;
        } catch (err) {
          console.error("[ContextualLayer] wrap error", err);
          markers = [];
        }
      }
      applyState(initialActive);

      toggle.addEventListener("click", () => {
        if (!processed) {
            try {
              markers = wrapContent(contentRoot);
            } catch (err) {
              console.error("[ContextualLayer] wrap error", err);
              markers = [];
            }
            processed = true;
        }
        const next = !active;
        applyState(next);
        persistState(next);
      });

      toggle.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          toggle.click();
        }
      });

      if (settingsButton && settingsPanel) {
        settingsButton.addEventListener("click", (event) => {
          event.preventDefault();
          toggleSettingsPanel();
        });
        settingsButton.setAttribute("aria-expanded", "false");
        settingsButton.setAttribute("aria-haspopup", "true");
      }

      densityButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          const val = btn.dataset.contextDensity === "first" ? "first" : "all";
          settings.density = val;
          syncSettingsUI();
          refreshMarkersHighlight();
          saveSettings();
        });
      });

      if (entitiesCheckbox) {
        entitiesCheckbox.addEventListener("change", () => {
          settings.showEntities = !!entitiesCheckbox.checked;
          refreshMarkersHighlight();
          saveSettings();
        });
      }
      if (glossaryCheckbox) {
        glossaryCheckbox.addEventListener("change", () => {
          settings.showGlossary = !!glossaryCheckbox.checked;
          refreshMarkersHighlight();
          saveSettings();
        });
      }
      if (floatToggle) {
        floatToggle.addEventListener("click", () => {
          settings.float = !settings.float;
          syncSettingsUI();
          floatUpdaters.forEach((fn) => fn());
          updateCollapsed(true);
          saveSettings();
        });
      }
      positionButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          const val = (btn.dataset.contextPosition || "hd").toLowerCase();
          settings.position = ["hd", "hg", "bd", "bg"].includes(val) ? val : "hd";
          syncSettingsUI();
          applyPosition();
          applyControlsLayout(floaterContainer?.dataset.ctxMode || "");
          floatUpdaters.forEach((fn) => fn());
          positionSettingsPanel();
          saveSettings();
        });
      });

      document.addEventListener("click", (event) => {
        const target = event.target;

        if (settingsPanelOpen) {
          const insidePanel = target?.closest && target.closest("[data-contextual-settings-panel]");
          const onButton = target?.closest && target.closest("[data-contextual-settings]");
          if (!insidePanel && !onButton) {
            hideSettingsPanel();
          }
        }

        if (!active) return;
        if (tooltip.contains(target)) return;
        if (target?.closest && target.closest("[data-context-term]")) return;
        hideTooltip();
      });

      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          hideTooltip();
          hideSettingsPanel();
        }
      });

      window.addEventListener("scroll", () => {
        updateTooltipPosition();
        updateCollapsed();
        positionSettingsPanel();
      }, { passive: true, capture: true });
      window.addEventListener("resize", () => {
        updateTooltipPosition();
        updateCollapsed(true);
        positionSettingsPanel();
      }, { passive: true });

      setupFloating(scope);
      updateCollapsed(true);
    }

    function wrapContent(root) {
      const collected = [];
      const occurrenceCount = new Map();
      const walker = document.createTreeWalker(
        root,
        NodeFilter.SHOW_TEXT,
        {
          acceptNode(node) {
            if (!node || !node.textContent || !node.textContent.trim()) return NodeFilter.FILTER_REJECT;
            const parent = node.parentElement;
            if (!parent) return NodeFilter.FILTER_REJECT;
            if (parent.closest("[data-context-term]")) return NodeFilter.FILTER_REJECT;
            if (skipTags.has(parent.tagName)) return NodeFilter.FILTER_REJECT;
            return NodeFilter.FILTER_ACCEPT;
          },
        },
      );

      const textNodes = [];
      let node;
      while ((node = walker.nextNode())) {
        textNodes.push(node);
      }

      textNodes.forEach((textNode) => {
        const newMarkers = wrapTextNode(textNode, occurrenceCount);
        collected.push(...newMarkers);
      });

      return collected;
    }

    function wrapTextNode(node, occurrenceCount) {
      const text = node.textContent || "";
      pattern.lastIndex = 0;
      let match;
      let lastIndex = 0;
      const frag = document.createDocumentFragment();
      const locals = [];
      let found = false;

      while ((match = pattern.exec(text))) {
        const start = match.index;
        const end = pattern.lastIndex;
        const prefix = match[1] ?? "";
        const matchedText = match[2] || match[0];
        const key = matchedText.toLocaleLowerCase("fr");
        const glossaryEntry = mapByKey.get(key);

        if (start > lastIndex) {
          frag.appendChild(document.createTextNode(text.slice(lastIndex, start)));
        }

        if (prefix) {
          frag.appendChild(document.createTextNode(prefix));
        }

        if (!glossaryEntry) {
          frag.appendChild(document.createTextNode(matchedText));
        } else {
          const count = occurrenceCount.get(key) || 0;
          const marker = createMarker(matchedText, glossaryEntry, count === 0);
          occurrenceCount.set(key, count + 1);
          frag.appendChild(marker);
          locals.push(marker);
        }

        lastIndex = end;
        found = true;
      }

      if (!found) return [];

      if (lastIndex < text.length) {
        frag.appendChild(document.createTextNode(text.slice(lastIndex)));
      }

      if (node.parentNode) {
        node.parentNode.replaceChild(frag, node);
      }

      return locals;
    }

    function createMarker(label, entry, isFirst) {
      const span = document.createElement("span");
      span.textContent = label;
      span.dataset.contextTerm = label;
      span.dataset.contextType = entry?.type || "glossary";
      span.dataset.contextFirst = isFirst ? "1" : "0";
      span.className = "mk-context-term relative inline-flex items-center";
      // attach data for tooltip rendering
      // @ts-ignore - custom property on DOM node
      span.__contextEntry = entry;
      span.tabIndex = -1;
      span.setAttribute("role", "button");
      span.setAttribute("aria-label", label + " : définition disponible");
      span.addEventListener("mouseenter", () => {
        if (!active || !isMarkerEnabled(span)) return;
        clearTimeout(hideTimer);
        showTooltip(span);
      });
      span.addEventListener("focus", () => {
        if (!active || !isMarkerEnabled(span)) return;
        clearTimeout(hideTimer);
        showTooltip(span);
      });
      span.addEventListener("mouseleave", () => {
        if (!active || !isMarkerEnabled(span)) return;
        hideTimer = window.setTimeout(hideTooltip, 120);
      });
      span.addEventListener("blur", () => {
        if (!active || !isMarkerEnabled(span)) return;
        hideTimer = window.setTimeout(hideTooltip, 120);
      });
      span.addEventListener("click", (event) => {
        if (!active || !isMarkerEnabled(span)) return;
        event.preventDefault();
        event.stopPropagation();
        clearTimeout(hideTimer);
        showTooltip(span);
      });
      span.addEventListener("keydown", (event) => {
        if (!active || !isMarkerEnabled(span)) return;
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          showTooltip(span);
        }
      });
      return span;
    }

    function createTooltip() {
      const el = document.createElement("div");
      el.className =
        "mk-context-tooltip fixed z-50 max-w-xs rounded-xl border border-slate-200 bg-white px-4 py-3 text-sm leading-relaxed text-slate-900 shadow-xl transition dark:border-slate-700 dark:bg-slate-900 dark:text-slate-100";
      el.style.display = "none";
      el.style.pointerEvents = "auto";
      document.body.appendChild(el);
      return el;
    }

    function escapeHtml(str = "") {
      return str.replace(/[&<>"']/g, (ch) => {
        switch (ch) {
          case "&":
            return "&amp;";
          case "<":
            return "&lt;";
          case ">":
            return "&gt;";
          case '"':
            return "&quot;";
          case "'":
            return "&#39;";
          default:
            return ch;
        }
      });
    }

    function renderTooltip(entry) {
      const type = entry?.type || "glossary";
      if (type === "entity") {
        const title = escapeHtml(entry?.title || entry?.name || "");
        const role = escapeHtml(entry?.role || "");
        const img = entry?.image
          ? `<div class="flex-shrink-0 w-12 h-12 overflow-hidden rounded-full bg-slate-100 dark:bg-slate-800 border border-slate-200 dark:border-slate-700"><img src="${entry.image}" alt="${title}" class="w-full h-full object-cover" loading="lazy" /></div>`
          : "";
        const roleHtml = role ? `<div class="text-sm text-slate-700 dark:text-slate-200">${role}</div>` : "";
        return `<div class="flex items-start gap-3">${img}<div><div class="font-semibold text-slate-900 dark:text-slate-50">${title}</div>${roleHtml}</div></div>`;
      }
      const def = escapeHtml(entry?.definition || "");
      return `<div class="text-sm text-slate-800 dark:text-slate-100">${def}</div>`;
    }

    function showTooltip(marker) {
      if (!active || !isMarkerEnabled(marker)) {
        hideTooltip();
        return;
      }
      // @ts-ignore - custom property on DOM node
      const entry = marker.__contextEntry || null;
      if (!entry) return;
      currentAnchor = marker;
      tooltip.innerHTML = renderTooltip(entry);
      tooltip.style.display = "block";
      positionTooltip(marker);
    }

    function hideTooltip() {
      tooltip.style.display = "none";
      currentAnchor = null;
    }

    function positionTooltip(marker) {
      const rect = marker.getBoundingClientRect();
      const tooltipRect = tooltip.getBoundingClientRect();
      const margin = 10;
      // position préférée : au-dessus, sinon en dessous
      let top = rect.top - tooltipRect.height - margin;
      let left = rect.left + rect.width / 2 - tooltipRect.width / 2;

      // si ça dépasse en haut, on passe en dessous
      if (top < margin) {
        top = rect.bottom + margin;
      }

      if (left < 12) left = 12;
      if (left + tooltipRect.width > window.innerWidth - 12) {
        left = window.innerWidth - tooltipRect.width - 12;
      }

      tooltip.style.top = top + "px";
      tooltip.style.left = left + "px";
    }

    function updateTooltipPosition() {
      if (!active || !currentAnchor) return;
      positionTooltip(currentAnchor);
    }

    function resetSettingsPanelPosition() {
      if (!settingsPanel) return;
      const props = ["position", "top", "left", "right", "bottom", "transform", "zIndex"];
      props.forEach((prop) => {
        // @ts-ignore
        settingsPanel.style[prop] = "";
      });
    }

    function positionSettingsPanel() {
      if (!settingsPanel || !settingsButton || !settingsPanelOpen) return;
      const isVerticalFloat = floaterContainer && floaterContainer.dataset.ctxMode === "vertical" && mobileMedia.matches;
      if (!isVerticalFloat) {
        resetSettingsPanelPosition();
        return;
      }
      const margin = 12;
      const toggleRect = toggle?.getBoundingClientRect();
      const settingsRect = settingsButton?.getBoundingClientRect();
      const anchorRect = (() => {
        const rects = [toggleRect, settingsRect].filter(Boolean);
        if (rects.length === 0) return floaterContainer.getBoundingClientRect();
        const left = Math.min(...rects.map((r) => r.left));
        const right = Math.max(...rects.map((r) => r.right));
        const top = Math.min(...rects.map((r) => r.top));
        const bottom = Math.max(...rects.map((r) => r.bottom));
        return {
          left,
          right,
          top,
          bottom,
          width: right - left,
          height: bottom - top,
        };
      })();
      const panelRect = settingsPanel.getBoundingClientRect();

      const centerY = anchorRect.top + anchorRect.height / 2;
      let top = centerY - panelRect.height / 2;
      top = Math.max(margin, Math.min(window.innerHeight - panelRect.height - margin, top));

      const preferredHand = floaterContainer.dataset.hand === "left" ? "left" : "right";
      const spaceLeft = anchorRect.left - margin;
      const spaceRight = window.innerWidth - anchorRect.right - margin;
      let side = preferredHand;
      if (side === "left" && panelRect.width > spaceLeft) {
        side = "right";
      } else if (side === "right" && panelRect.width > spaceRight) {
        side = "left";
      }

      let left =
        side === "left"
          ? anchorRect.left - panelRect.width - margin
          : anchorRect.right + margin;
      left = Math.max(margin, Math.min(window.innerWidth - panelRect.width - margin, left));

      settingsPanel.style.position = "fixed";
      settingsPanel.style.top = `${top}px`;
      settingsPanel.style.left = `${left}px`;
      settingsPanel.style.right = "auto";
      settingsPanel.style.bottom = "auto";
      settingsPanel.style.zIndex = "70";
    }

    function toggleSettingsPanel() {
      if (!settingsPanel || !settingsButton) return;
      if (settingsPanelOpen) {
        hideSettingsPanel();
      } else {
        settingsPanel.classList.remove("hidden");
        settingsButton.setAttribute("aria-expanded", "true");
        settingsPanelOpen = true;
        positionSettingsPanel();
      }
    }

    function hideSettingsPanel() {
      if (!settingsPanel || !settingsButton) return;
      if (!settingsPanelOpen) return;
      settingsPanel.classList.add("hidden");
      settingsButton.setAttribute("aria-expanded", "false");
      settingsPanelOpen = false;
      resetSettingsPanelPosition();
    }

    function loadSettings() {
      try {
        const raw = localStorage.getItem(SETTINGS_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed === "object") {
          settings.density = parsed.density === "first" ? "first" : "all";
          settings.showEntities = parsed.showEntities !== false;
          settings.showGlossary = parsed.showGlossary !== false;
          settings.float = parsed.float !== false;
          const legacyHand = parsed.handedness === "left" ? "hg" : "hd";
          const pos = (parsed.position || "").toLowerCase();
          settings.position = ["hd", "hg", "bd", "bg"].includes(pos) ? pos : legacyHand;
        }
      } catch (_) {
        // ignore
      }
    }

    function saveSettings() {
      try {
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
      } catch (_) {
        // ignore
      }
    }

    function applyPosition() {
      const isVertical = controlsContainer?.dataset.ctxMode === "vertical";
      const side = settings.position.endsWith("g") ? "left" : "right";
      if (controlsContainer) {
        controlsContainer.dataset.hand = isVertical ? "center" : side;
        controlsContainer.classList.remove("justify-end", "justify-start", "flex-row-reverse");
        if (!isVertical) {
          if (side === "right") {
            controlsContainer.classList.add("justify-end");
          } else {
            controlsContainer.classList.add("justify-end", "flex-row-reverse");
          }
        }
      }
      if (floaterContainer) {
        floaterContainer.dataset.hand = side;
      }
      floatUpdaters.forEach((fn) => fn());
      positionSettingsPanel();
      if (settingsPanel) {
        settingsPanel.classList.remove("right-0", "left-0", "right-auto", "left-auto");
        if (side === "right") {
          settingsPanel.classList.add("right-0", "left-auto");
        } else {
          settingsPanel.classList.add("left-0", "right-auto");
        }
      }
    }

    function applyControlsLayout(mode) {
      const vertical = mode === "vertical";
      if (controlsContainer) {
        controlsContainer.dataset.ctxMode = vertical ? "vertical" : "";
        const side = settings.position.endsWith("g") ? "left" : "right";
        controlsContainer.dataset.hand = vertical ? "center" : side;
        const props = ["display", "gridAutoFlow", "alignItems", "justifyItems", "justifyContent", "rowGap", "width", "alignSelf", "marginInline"];
        props.forEach((prop) => {
          // @ts-ignore
          controlsContainer.style[prop] = "";
        });
        if (vertical) {
          controlsContainer.style.display = "grid";
          controlsContainer.style.gridAutoFlow = "row";
          controlsContainer.style.alignItems = "center";
          controlsContainer.style.justifyItems = "center";
          controlsContainer.style.justifyContent = "center";
          controlsContainer.style.rowGap = "0.5rem";
        }
      }
      if (toggle) {
        toggle.style.order = vertical ? "1" : "";
        toggle.style.alignSelf = vertical ? "center" : "";
      }
      if (settingsButton) {
        settingsButton.style.order = vertical ? "2" : "";
        settingsButton.style.alignSelf = vertical ? "center" : "";
      }
      positionSettingsPanel();
    }

    function isMarkerEnabled(marker) {
      const type = marker.dataset.contextType || "glossary";
      const isFirst = marker.dataset.contextFirst === "1";
      if (type === "entity" && !settings.showEntities) return false;
      if (type !== "entity" && !settings.showGlossary) return false;
      if (settings.density === "first" && !isFirst) return false;
      return true;
    }

    function refreshMarkersHighlight() {
      applyState(active);
    }

    function syncSettingsUI() {
      const basePositionBtnClasses = [
        "inline-flex",
        "items-center",
        "justify-center",
        "rounded-full",
        "border",
        "px-3",
        "py-1.5",
        "text-sm",
        "font-semibold",
        "transition",
        "hover:-translate-y-[1px]",
        "hover:shadow-sm",
      ];
      densityButtons.forEach((btn) => {
        const isActive = btn.dataset.contextDensity === settings.density;
        btn.classList.toggle("border-amber-400", isActive);
        btn.classList.toggle("bg-amber-50", isActive);
        btn.classList.toggle("text-amber-900", isActive);
        btn.classList.toggle("dark:border-amber-300/70", isActive);
        btn.classList.toggle("dark:bg-amber-900/30", isActive);
        btn.classList.toggle("dark:text-amber-50", isActive);
        btn.classList.toggle("border-slate-200", !isActive);
        btn.classList.toggle("bg-white", !isActive);
        btn.classList.toggle("text-slate-800", !isActive);
        btn.classList.toggle("dark:border-slate-700", !isActive);
        btn.classList.toggle("dark:bg-slate-900", !isActive);
        btn.classList.toggle("dark:text-slate-100", !isActive);
      });
      if (entitiesCheckbox) entitiesCheckbox.checked = settings.showEntities;
      if (glossaryCheckbox) glossaryCheckbox.checked = settings.showGlossary;
      if (floatToggle) {
        const isActive = settings.float;
        floatToggle.classList.toggle("border-amber-400", isActive);
        floatToggle.classList.toggle("bg-amber-50", isActive);
        floatToggle.classList.toggle("text-amber-900", isActive);
        floatToggle.classList.toggle("dark:border-amber-300/70", isActive);
        floatToggle.classList.toggle("dark:bg-amber-900/30", isActive);
        floatToggle.classList.toggle("dark:text-amber-50", isActive);
        floatToggle.classList.toggle("border-slate-200", !isActive);
        floatToggle.classList.toggle("bg-white", !isActive);
        floatToggle.classList.toggle("text-slate-800", !isActive);
        floatToggle.classList.toggle("dark:border-slate-700", !isActive);
        floatToggle.classList.toggle("dark:bg-slate-900", !isActive);
        floatToggle.classList.toggle("dark:text-slate-100", !isActive);
      }
      positionButtons.forEach((btn) => {
        const btnPos = (btn.dataset.contextPosition || "").toLowerCase();
        const isActive = btnPos === settings.position;
        const activeClasses = [
          "border-amber-400",
          "bg-amber-50",
          "text-amber-900",
          "dark:border-amber-300/70",
          "dark:bg-amber-900/30",
          "dark:text-amber-50",
        ];
        const inactiveClasses = [
          "border-slate-200",
          "bg-white",
          "text-slate-800",
          "dark:border-slate-700",
          "dark:bg-slate-900",
          "dark:text-slate-100",
        ];
        btn.className = "";
        btn.classList.add(...basePositionBtnClasses, ...(isActive ? activeClasses : inactiveClasses));
        btn.setAttribute("aria-pressed", String(isActive));
      });
    }

    function updateCollapsed(force = false) {
      const threshold = 100;
      const floater = toggle.closest?.("[data-contextual-floater]");
      let next = false;
      const isBottomPosition = settings.position.startsWith("b");

      if (!settings.float) {
        if (collapsed) {
          collapsed = false;
          toggle.classList.remove("contextual-collapsed");
        }
        return;
      }

      if (isBottomPosition) {
        if (collapsed) {
          collapsed = false;
          toggle.classList.remove("contextual-collapsed");
        }
        return;
      }

      if (floater && settings.float) {
        const shouldFloat = floater.dataset.ctxFloating === "1";
        const triggerTop = parseFloat(floater.dataset.ctxTrigger || "0");
        const margin = parseFloat(floater.dataset.ctxMargin || "0");
        const distance = window.scrollY + margin - triggerTop;
        next = shouldFloat && distance > threshold;
      } else {
        next = window.scrollY > threshold;
      }

      if (!force && next === collapsed) return;
      collapsed = next;
      toggle.classList.toggle("contextual-collapsed", collapsed);
    }

    function setupFloating(root) {
      const floaters = Array.from(root.querySelectorAll("[data-contextual-floater]"));
      if (!floaters.length) return;

      floaters.forEach((floater) => {
        if (floater.dataset.floatingInit) return;
        floater.dataset.floatingInit = "1";

        const placeholder = document.createElement("div");
        placeholder.style.height = "0px";
        placeholder.style.width = "100%";
        placeholder.style.pointerEvents = "none";
        placeholder.dataset.contextualPlaceholder = "1";

        floater.parentElement?.insertBefore(placeholder, floater);
        const margin = 16;

        const resetStyles = () => {
          floater.style.position = "";
          floater.style.top = "";
          floater.style.left = "";
          floater.style.right = "";
          floater.style.bottom = "";
          floater.style.width = "";
          floater.style.zIndex = "";
          floater.dataset.ctxFloating = "0";
          floater.dataset.ctxMode = "";
          floater.dataset.ctxTrigger = "0";
          floater.dataset.ctxMargin = String(margin);
          applyControlsLayout("");
        };

        const updateFloating = () => {
          const prevRect = floater.getBoundingClientRect();
          const wasFloating = floater.dataset.ctxFloating === "1";
          floater.style.position = "";
          const placeholderRect = placeholder.getBoundingClientRect();
          const floaterRect = floater.getBoundingClientRect();
          const collapsedHeight = toggle?.getBoundingClientRect().height || floaterRect.height;
          const expandedHeight = controlsContainer?.getBoundingClientRect().height || floaterRect.height;
          const side = settings.position.endsWith("g") ? "left" : "right";
          const isBottom = settings.position.startsWith("b");
          const baseTrigger = placeholderRect.top + window.scrollY;
          const triggerTop = isBottom ? baseTrigger : baseTrigger - margin;
          const shouldFloat = settings.float && window.scrollY >= triggerTop;
          const verticalMode = isBottom && shouldFloat;

          if (!settings.float) {
            const idleHeight = verticalMode ? expandedHeight : 0;
            placeholder.style.height = `${idleHeight}px`;
            floater.style.position = "relative";
            floater.style.top = "";
            floater.style.left = "";
            floater.style.width = "";
            floater.style.zIndex = "";
            floater.dataset.ctxFloating = "0";
            floater.dataset.ctxMode = "";
            floater.dataset.ctxTrigger = "0";
            floater.dataset.ctxMargin = String(margin);
            applyControlsLayout("");
            return;
          }

          floater.dataset.ctxFloating = shouldFloat ? "1" : "0";
          floater.dataset.ctxTrigger = String(triggerTop);
          floater.dataset.ctxMargin = String(margin);
          floater.dataset.hand = side;

          if (!verticalMode) {
            updateCollapsed(true);
          }

          const baseFloatHeight = floaterRect.height || collapsedHeight;
          placeholder.style.height = shouldFloat ? `${baseFloatHeight}px` : "0px";

          if (verticalMode) {
            floater.style.position = "fixed";
            floater.style.zIndex = "60";
            floater.style.top = "auto";
            floater.style.bottom = `calc(30vh + env(safe-area-inset-bottom, 0px))`;
            floater.style.width = "auto";
            floater.style.left = side === "left" ? "1rem" : "auto";
            floater.style.right = side === "right" ? "1rem" : "auto";
            floater.dataset.ctxMode = "vertical";
            applyControlsLayout("vertical");
          } else {
            floater.dataset.ctxMode = "";
            applyControlsLayout("");
            // HD/HG : revenir en fixed pour suivre le scroll, avec hauteur compacte constante.
            if (shouldFloat) {
              floater.style.position = "fixed";
              floater.style.top = `${margin}px`;
              floater.style.bottom = "";
              floater.style.width = `${placeholderRect.width || floaterRect.width}px`;
              floater.style.left = `${placeholderRect.left}px`;
              floater.style.right = "";
              floater.style.zIndex = "60";
            } else {
              floater.style.position = "relative";
              floater.style.top = "";
              floater.style.left = "";
              floater.style.right = "";
              floater.style.bottom = "";
              floater.style.width = "100%";
              floater.style.zIndex = "";
            }
          }

          void prevRect;
          void wasFloating;
          positionSettingsPanel();
        };

        const handleResize = () => {
          placeholder.style.height = "0px";
          resetStyles();
          requestAnimationFrame(updateFloating);
        };

        window.addEventListener("scroll", updateFloating, { passive: true });
        window.addEventListener("resize", handleResize, { passive: true });
        updateFloating();
        floatUpdaters.push(updateFloating);
      });
    }

    init();
  })();
</script>

<style is:global>
  [data-contextual-toggle] {
    transition:
      padding 160ms ease,
      gap 160ms ease,
      background-color 140ms ease,
      border-color 140ms ease,
      box-shadow 140ms ease;
  }
  [data-contextual-toggle] [data-contextual-label] {
    display: inline-flex;
    max-width: 160px;
    overflow: hidden;
    white-space: nowrap;
    transition: max-width 180ms ease, opacity 160ms ease, margin 160ms ease;
  }
  [data-contextual-toggle].contextual-collapsed {
    padding-left: 0.75rem !important;
    padding-right: 0.75rem !important;
    gap: 0.35rem !important;
  }
  [data-contextual-toggle].contextual-collapsed [data-contextual-label] {
    max-width: 0;
    opacity: 0;
    margin: 0;
  }

  [data-context-controls][data-hand="right"] > * {
    transform: translateX(0);
  }
  [data-contextual-floater][data-ctx-mode="vertical"] [data-contextual-controls] > *,
  [data-contextual-controls][data-ctx-mode="vertical"] > * {
    transform: none !important;
  }

  [data-contextual-floater][data-ctx-mode="vertical"] [data-contextual-controls],
  [data-contextual-controls][data-ctx-mode="vertical"] {
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
  }
  [data-contextual-floater][data-ctx-mode="vertical"] [data-contextual-controls][data-hand="left"],
  [data-contextual-controls][data-ctx-mode="vertical"][data-hand="left"] {
    align-items: center;
  }
  [data-contextual-floater][data-ctx-mode="vertical"] [data-contextual-toggle],
  [data-contextual-controls][data-ctx-mode="vertical"] [data-contextual-toggle] {
    order: 1;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: auto;
    padding: 0.3rem 0.5rem;
    gap: 0.1rem;
    width: 2.75rem;
    min-width: 2.75rem;
    line-height: 1;
  }
  [data-contextual-floater][data-ctx-mode="vertical"] [data-contextual-toggle].contextual-collapsed,
  [data-contextual-controls][data-ctx-mode="vertical"] [data-contextual-toggle].contextual-collapsed {
    padding-left: 0.3rem !important;
    padding-right: 0.3rem !important;
    gap: 0.1rem !important;
  }
  [data-contextual-floater][data-ctx-mode="vertical"] [data-contextual-settings],
  [data-contextual-controls][data-ctx-mode="vertical"] [data-contextual-settings] {
    order: 2;
    align-self: center;
  }
  [data-contextual-floater][data-ctx-mode="vertical"] [data-contextual-toggle] [data-contextual-label],
  [data-contextual-controls][data-ctx-mode="vertical"] [data-contextual-toggle] [data-contextual-label] {
    display: none;
  }
  [data-contextual-floater][data-ctx-mode="vertical"] [data-contextual-toggle] img,
  [data-contextual-controls][data-ctx-mode="vertical"] [data-contextual-toggle] img {
    width: 1.25rem;
    height: 1.25rem;
    margin: 0;
  }
</style>
